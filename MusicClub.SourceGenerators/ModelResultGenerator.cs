using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace MusicClub.SourceGenerators
{
    [Generator]
    public class ModelResultGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxReceiver is ClassSyntaxReceiver receiver))
                return;

            var namespaces = new List<string>();
 
            var editRazorClasses = receiver.Classes.Where(x => x.Identifier.Text.Equals("Edit", StringComparison.OrdinalIgnoreCase));

            foreach (var classDeclaration in editRazorClasses)
            {
                var model = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);


                var classSymbol = model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

                if (classSymbol == null)
                    continue;


                // Check if the class is in the desired namespace
                var classNamespace = classSymbol.ContainingNamespace.ToDisplayString(); // e.g., "MyProject.Models"

                if (classNamespace.StartsWith("MusicClub.Cms.Blazor.Pages"))
                {
                    namespaces.Add(classNamespace.Split('.').Last());
                }



                //if (classNamespace.StartsWith("MusicClub.Cms.Blazor.Pages"))
                //{
                //    context.AddSource($"{classSymbol.Name}Result.g.cs", $"namespace MusicClub.Cms.Blazor.Pages {{ public class {classSymbol.Name}Result {{ }} }} ");

                //}

            }

            var namespacesString = string.Join(",", namespaces);

            context.AddSource($"DataController.g.cs", $"// <auto-generated/> \n using System;using System.Diagnostics; namespace MusicClub.Cms.Blazor.Services {{ public partial class DataController {{ private string GetNamespaces() {{ return \"{namespacesString}\"; }} }} }} ");



            //foreach (var classDeclaration in receiver.Classes)
            //{
            //    // Get the semantic model for the class declaration's syntax tree
            //    var model = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);

            //    // Get the symbol information for the class (this gives access to namespaces and types)
            //    var classSymbol = model.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            //    if (classSymbol == null)
            //        continue;

            //    // Check if the class is in the desired namespace
            //    var classNamespace = classSymbol.ContainingNamespace.ToDisplayString(); // e.g., "MyProject.Models"
            //    if (classNamespace == "MusicClub.Testzone.Models")
            //    {
            //        // Generate code for classes in the specified namespace
            //        var className = classSymbol.Name;
            //        var properties = classSymbol.GetMembers().OfType<IPropertySymbol>();
            //        string generatedClass = GenerateResultClass(classNamespace, className, properties);

            //        context.AddSource($"{className}Result.g.cs", generatedClass);
            //    }
            //}
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // Register a syntax receiver to collect class declarations
            context.RegisterForSyntaxNotifications(() => new ClassSyntaxReceiver());
        }

        private string GenerateResultClass(string classNamespace, string className, IEnumerable<IPropertySymbol> properties)
        {
            //var propertiesCode = string.Join("\n", properties.Select(p =>
            //    $"public {p.Type} {p.Name} {{ get; set; }}"));

            var propertiesBuilder = new StringBuilder();

            foreach (var property in properties)
            {
                propertiesBuilder.AppendLine($"\t\tpublic {(property.IsRequired ? "required" : "")} {property.Type} {property.Name} {{ get; set; }}");

                if (property.Name != "Id" && property.Name.EndsWith("Id"))
                {
                    if (property.NullableAnnotation is NullableAnnotation.Annotated)
                    {
                        propertiesBuilder.AppendLine($"\t\tpublic {property.Name.Replace("Id", "Result")}? {property.Name.Replace("Id", "Result")} {{ get; set; }}");

                    }
                    else if (property.IsRequired)
                    {
                        propertiesBuilder.AppendLine($"\t\tpublic required {property.Name.Replace("Id", "Result")} {property.Name.Replace("Id", "Result")} {{ get; set; }}");
                    }
                    else
                    {
                        propertiesBuilder.AppendLine($"\t\tpublic {property.Name.Replace("Id", "Result")} {property.Name.Replace("Id", "Result")} {{ get; set; }}");

                    }
                }
            }

            var propertiesCode = propertiesBuilder.ToString();

            return
            $@"// <auto-generated/>
    using System;

    namespace {classNamespace}
    {{
        public class {className}Result
        {{
            {propertiesCode}

            public string AdditionalProperty {{ get; set; }}
        }}
    }}";
        }
    }

    public class ClassSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> Classes { get; } = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Collect all class declarations
            if (syntaxNode is ClassDeclarationSyntax classDeclaration)
            {
                Classes.Add(classDeclaration);
            }
        }
    }
}
